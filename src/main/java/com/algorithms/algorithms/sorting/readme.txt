排序(sorting)
一.初级排序
    (1)基本概念
        排序就是将一组对象按照某种逻辑顺序重新排列的过程。

        几个对于所有排序算法都很重要的问题——
           ①验证
                排序算法是否成功?
           ②运行时间
                评估算法的性能——需要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次
           数)。
           ③额外的内存使用
                排序算法的额外内存开销和运行时间同等重要——原地排序算法和其他排序算法。
           ④数据类型
                Java中实现了Comparable结构的类型。具体实现其中的compareTo()方法，该方法需要做到全序关系，即自反性、反对称性(v>w则
                w<v)、传递性等。该方法实现了对待排序数组的主键抽象(所谓主键就是用于排序时，拿来比较的那个成员变量)。

           不同算法之间比较的步骤+
           ①实现并调试它们;
           ②分析它们的基本性质;
           ③对它们的相对性能做出猜想;
           ④用实验验证我们的猜想。
            实现代码————>分析————>猜想————>实验验证

           ★通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因之一。

    (2)几种基本排序
            之所以研究多种排序算法的一个原因之一是许多排序算法的性能都和输入模型有很大的关系，因此不同的算法适用于不同的
     应用场景中的不同输入。

    ===>选择排序(冒泡排序)
            不断选择剩余元素中的最小者，将之依次放入相关位置。

            特点——①运行时间和输入无关——为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。
                  ②数据移动是最少的——交换次数只和数组的大小是线性关系(因为大部分时候都是针对索引的操作)。

            命题——对于长度为N的数组，选择排序需要大约(Ne2)/2次比较和N次交换。

    ===>插入排序
            与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定————直到索引到达最右边。

            特点——①(和选择排序不同的是)插入排序所需的时间取决于输入中元素的初始顺序。
                  ②插入排序对于实际应用中常见的某些类型的非随机数组很有效。

            命题——对于随机的长度为N且不重复的数组，平均情况下需要(Ne2)/4次比较以及(Ne2)/4次交换。最坏情况下需要(Ne2)/2
                    次比较和(Ne2)/2次交换。最好情况下需要(N-1)次比较和0次交换。

            部分有序——如果数组中倒置对的数量小于数组大小的某个倍数，我们就说这个数组是部分有序的。如下描述的情况都是部分有序的————
                    ①数组中每个元素距离它的最终位置都不远;
                    ②一个有序的大数组接一个小数组;
                    ③数组中只有几个元素的位置不正确;

             要大幅提高插入排序的速度并不难，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素(这样访问数组的次
             数就能减半————一次平移访问两次数组，一次交换访问四次数组)。

             总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组。这样的数组在高级排序算法的中间过程中很容易
             出现。

    ===>希尔排序(缩小增量排序)
             是插入排序的简单改进，用于交换不相邻的元素以对数组的局部进行排序。

             希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。换句话说，一个h有序数组就是h个互相独立的
             有序数组编织在一起组成的一个数组。是非稳定排序。因而其性能难以确定。

             特点——①希尔排序更高效的原因时它权衡了子数组的规模和有序性。
                   ②希尔排序的运行时间达不到平方级别。当递增序列为3h+1时，其最坏情况下的比较次数和(Ne(3/2))成正比。

             希尔排序的递增序列(即h的数组)可以实时生成，也可以一次计算然后将之放入数组中。

二.归并排序
    ===>归并排序
              将一个数组排序，可以先(递归地)将它分成两半分别排序，然后将结果归并起来。
              归并排序具体可以分为自顶向下归并排序和自底向上归并排序——
        (1)自顶向下归并排序——
            sort()方法的作用其实在于安排多次merge()方法调用的正确顺序。

            特点——①分治思想
                  ②最吸引人的地方在于它能够保证将任意长度为N的数组排序所需时间和NlogN成正比;它的主要缺点则是它所需的
                   额外空间和N成正比。

            命题——①对于长度为N的任意数组，自顶向下的归并排序需要(1/2)NlgN到NlgN次比较。
                  ②对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组6NlgN次。
                  ③缺点在于辅助数组所使用的额外空间和N的大小成正比。

            改进——①对小规模子数组使用插入排序(可将运行时间缩短10%-15%)(练习2.2.23)
                        用不同的方法处理小规模问题能改进大多数递归算法的性能，因为递归会使小规模问题中方法的调用过于
                        频繁，所以改进对它们的处理方法就能改进整个算法。
                    ②测试数组是否已经有序(练习2.2.8)
                        添加一个判断条件，如果a[mid]小于等于a[mid+1]，我们就认为数组已经有序并跳过merge(...)方法。
                    ③不将元素复制到辅助数组(练习2.2.11)
                        可以节省将数组复制到用于归并的辅助数组所用的时间(但不能节省空间)。在递归调用的每个层次交换输入数
                        组和辅助数组的角色。

            并不是在推荐读者一定要实现所提到的这些改进方法，而是提醒大家不要对算法初始实现的性能盖棺定论。研究一个问题时，
            最好的方法是先实现一个你能想到的最简单的程序，当它成为瓶颈的时候再继续改进它。

        (2)自底向上的归并排序
            归并的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组。如此这般，直到我们将整个数组归并在一起。在
            每一轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小。
            自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小sz的初始值为1，每次加倍。最后一
            个子数组的大小只有在数组大小是sz的偶数倍的时候才会等于sz(否则其会比sz小)。

            命题——对于长度为N的任意数组，自底向上的归并排序需要(1/2)NlgN至NlgN次比较，最多访问数组6NlgN次。

        (3)两者的比较——
            比较——
                ①当数组长度为2的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。
                ②抽象来看，自顶向下更像是用递归的方式来归并解决问题;而自底向上更像是用迭代的思想来归并解决问题。所以后
                者更适用于链表。
            综述——
                排序算法是证明计算复杂性领域的一个重要结论的基础。计算复杂性能够帮助我们理解排序自身固有的难易程度。

                研究复杂度的第一步是建立一个计算模型

                命题——①没有任何基于比较的算法能够保证使用少于NlgN(lg(N!)近似结果)次比较将长度为N的数组排序。该结论告
                       诉了我们在设计排序算法的时候能够达到的最佳效果————注意是基于比较的排序算法，这个前提很重要。
                      ②归并排序是一种渐进最优的基于比较排序的算法。

            计算复杂度——
                    首先准确的算法复杂度上界为软件工程师保证性能提供了空间。其次，准确的下界可以为我们节省很多时间，避免
                    因不可能的性能改进而投入资源。

            进一步——
                    但归并排序的最优性并不是结束，因为上述的理论还有很多的局限性——
                    ①归并排序的空间复杂度不是最优的;
                    ②在实践中不一定不会遇到最坏情况;
                    ③除了比较，算法的其他操作(例如访问数组)也可能很重要;
                    ④有不进行比较也能将某些数据排序的算法。

三.快速排序
    ===>快速排序
            快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。

            快速排序和归并排序是互补的——
            ①归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序;而快速排序将数组排序的方式则是
            当两个子数组都有序时整个数组也就自然有序了。
            ②归并排序的递归调用发生在处理整个数组之前;快速排序的递归调用发生在处理整个数组之后。
            ③归并排序中，一个数组被等分为两半;快速排序中，切分(partition)的位置取决于数组的内容。

            特点——①优点在于其是原地排序(只需要一个很小的辅助栈————用于存放切分元素)。在保证空间的情况下，保证了将长度为N的数组排序
                   所需的时间和NlgN成正比。
                  ②缺点在于其非常脆弱，在实现时要非常小心才能避免低劣的性能————如切分不平衡。

            快速排序的几个细节——
                    ①原地切分————如果加辅助数组会增加开销。
                    ②别越界————小心别让扫描指针跑出数组边界。
                    ③保持输入数据的随机性————或者让切分元素的位置随机。
                    ④注意必要时终止循环————常见错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素。
                    ⑤处理切分元素有重复的情况————左扫描最好遇到大于等于切分元素值的元素时停下;右扫描则是遇到小于等于切
                      分元素值的元素时停下。
                    ⑥终止递归,必要时停止递归————常见错误是不能保证将切分元素放入正确位置，从而导致程序在切分元素正好
                      是子数组的最大或最小元素时陷入了无限的递归循环中。

            快速排序性能研究——
                    ①快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较，其移动数据的次数更少;
                    ②快速排序另一个速度优势在于它的比较次数很少;
                    ③快速排序的最好情况是每次都正好能将数组对半分。

            改进——①排序小数组时切换到插入排序————基于两点，一是对于小数组，快速排序比插入排序慢;而是因为递归，快速排
                   序的sort()方法在小数组中也会调用自己。(练习2.3.25)
                  ②三取样切分————使用子数组的一小部分元素的中位数来切分数组。但代价是需要计算中位数(一种方式是取样3
                   并用第二大的那个位置的值为切分元素)。(练习2.3.18、2.3.19)
                  ③♤熵最优排序(三向切分)————
                   在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现。一个简单的办法就是
                   将数组切分为三部分，分别对应于小于、等于和大于切分元素的数组元素。这就好像是用三种可能的主键值
                   将数组排序一样。

            命题——①将长度为N的无重复数组排序，快速排序平均需要～2NlnN次比较(以及1/6次比较次数的交换次数)。
                  ②快速排序最多需要约(Ne2)/2次比较(此时就像是选择排序)，但随机打乱数组能够预防这种情况。
                  ③不存在任何基于比较的排序算法能够保证在NH-N次比较之内将N个元素排序，其中H为由主键值出现频率定义的
                   香农信息量;
                  ④对于大小为N的数组，三向切分的快速排序需要～(2ln2)NH次比较。其中H为由主键值出现频率定义的香农信息
                   量。

                    香农信息量(对信息含量的一种标准)——给定包含k个不同值的N个主键，对于从1到k的每个i，定义fi为第i个主
                    键值出现的次数，pi为,fi/N，即为随机抽取一个数组元素时第i个主键值出现的概率。那么所有主键的香农信息
                    量可以定义为——
                                    H=-(p1*lgp1+p1*lgp1+p1*lgp1+...+pk*lgpk)
                    元素概率分布决定了信息量的大小。
                    信息量最优就是指对输入数组的了解程度平均值就是1.39NlgN.

四.优先队列
    (1)优先队列
            许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。很多情况下我们会
        收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素，如此反复。
            满足上述要求的数据结构被称为优先队列。基于优先队列排序的算法我们称为堆排序。
            优先队列最重要的操作就是删除最大元素和插入元素。


    ===>二叉堆
            ①二叉树到二叉堆
            定义与命题——①定义————当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。
                       ②命题————根节点是堆有序的二叉树中的最大结点。

            二叉树的表示————完全二叉树只用数组而不需要指针就可以表示。具体是将二叉树的结点按照层级顺序放入数组中。

            在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应地，这些位置的元素又至少要大于等于数组中
            的另两个元素，以此类推。

            定义————二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储(不使用数组的第一个位置)。

            使用数组来表示二叉堆的时候，位置k的结点的父结点的位置索引最大为k/2(如果不是完全二叉堆，则小于k/2)，而它的两个子结点的
            位置则分别为2k和2k+1。

            ②二叉堆的算法
            二叉堆的操作——堆的操作会首先进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复，我们称
            这个过程叫做堆的有序化(reheapifying).
            在有序化的过程中，我们会遇到两种情况。某个结点的优先级上升(或是在堆底加入一个新的元素)时，我们需要由下至上恢
            复堆的顺序。当某个结点的优先级下降(如将根结点替换为一个较小的元素)时，我们需要由上至下恢复堆的顺序。

            Ⅰ.由下至上的堆有序化(上浮)
            如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。
            Ⅱ.由上至下的堆有序化(下沉)
            如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么我们可以通过将它和它的两个
            子结点中的较大者交换来恢复堆。

            基于上述的"上浮"与"下沉"，在优先队列中，我们的操作逻辑如下————
            插入元素————将新元素加到数组末尾，增加堆的大小N并让这个新元素上浮到合适的位置。
            删除最大元素————从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适
                           的位置。

            ③命题——对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过(lgN+1)次比较，删除最大元素的操作需要
                   不超过2lgN次比较(因为对于一个结点，其需要两次比较————除了堆底元素)。


            ④索引优先队列与多项归并问题 P205页
            具体思路就是，从不同的输入每次取一个数据，然后和其他的比较。类似归并排序的分治思想。

    ===>堆排序
            将优先队列变成一种排序方法————将所有元素插入一个查找最小元素的优先队列，然后再重复调用删除最小元素的操作将它
            们按顺序删去。
            无序优先队列————快速排序(每次取数据的时候才排序找到最大/最小值);有序优先队列————堆排序。

            堆排序可以分为两个阶段——①堆的构造阶段，将原始数组重新组织安排进一个堆中;
                                  ②然后在下沉排序阶段，从堆中按递减顺序取出所有元素并得到排序结果。

            命题——①用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换;
                  ②将N个元素排序，堆排序只需少于(2NlgN+2N)次比较(以及一半次数的交换)。

            两种堆排序方式，主要是在第二阶段排序阶段，有两种方式————
                    ①下沉排序
                    ②先下沉后上浮——通过免去检查元素是否到达正确位置来节省时间。在下沉中总是直接提升较大的子结点直至到
                                  达堆底，然后再使元素上浮到正确位置——即下沉时不比较父子节点。当之前父结点沉底后再
                                  用上浮(swim())比较(升序相对于降序只会比较一次)。

            综述——①堆排序在排序复杂性研究中有着重要的地位。因为它是我们所知的唯一能够同时最优地利用空间和时间的方法。
                      在最坏的情况下它也能保证使用～2NlgN次比较和恒定的额外空间。
                    ②因为它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较
                      都在相邻元素间进行的算法。
                    ③它能在插入操作和删除最大元素操作混合的动态场景中保证对数级别的运行时间。



            特点——①无需任何额外空间。


五.应用
            1.问题的规约
            (1)规约指的是为解决某个问题而发明的算法正好可以用来解决另一种问题。
                排名问题(Kendall tau距离)、找出重复元素问题、优先队列(将多个输入流归并为一个输出流)、
            2.排序的应用
                商业计算、信息搜索、组合搜索、霍夫曼压缩、字符串处理、运筹学(运筹学指的是研究数学模型并将其应
                用于问题解决和决策的领域——最短优先与负载均衡都可以使用优先队列来实现)、
                数值计算(一些数值计算算法使用优先队列和排序来控制计算中的精确度——如求曲线下区域的面积时，数值积分的
                一个方法就是使用一个优先队列存储一组间隔中每段的近似精确度。积分的过程就是删去精确度最低的间隔并将其
                分为两半(这样两半都能变得更加精确)，然后将两半都重新加入优先队列中。如此这般直到达到预期的精确程度)。



