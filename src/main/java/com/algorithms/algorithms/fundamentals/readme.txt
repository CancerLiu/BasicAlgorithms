一.基础编程模型
性能是算法的核心问题——研究算法的基本做法是科学式的，即先对性能提出假设，建立数学模型，然后用多种实验验证它们，必要时
重复这个过程。

算法——用于描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。
数据结构——是算法的副产品或结果。重点是数据抽象并定义抽象数据类型(ADT)以进行模块化编程。

学习算法的主要原因是它们能节约非常多的资源，甚至能够让我们完成一些本不可能完成的任务。

在编写庞大或者复杂的程序时，理解和定义问题、控制问题的复杂度和将其分解为更容易解决的子问题需要大量的工作。
从一些基本算法入手，是蛮不错的手段。因为复杂的算法肯定来自于基础的算法。

我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为基础编程模型。

拥抱数据抽象——
简单的说，数据抽象的主要思想是鼓励程序定义自己的数据类型(一系列值和对这些值的操作)。
使用数据抽象的三点原因——
(1)允许我们通过模块化编程复用代码
(2)使我们可以轻易构造多种所谓的链式数据结构
(3)借助它我们可以准确地定义所面对的算法问题——其解决一个问题的方式都是定义数据结构并高效地实现它们的一组操作。

递归——
就是方法中自己调用自己。递归代码比相应的非递归代码更加简洁优雅、易懂。编写递归代码时。使用递归的另一个原因是我们可以使用
数学模型来估计程序的性能。具体使用时最重要的有以下三点:
(1)递归总有一个最简单的情况——方法的第一条语句总是一个包含return的条件语句。
(2)递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。
(3)递归调用的父问题和尝试解决的子问题之间不应该有交集。

二.数据抽象
数据类型指的是一组值和一组对这些值的操作的集合。

抽象数据类型(ADT)是一种能够对使用者隐藏数据表示的数据类型。其将数据和函数的实现关联，并将数据的表示方式隐藏起来。

设计数据类型时需要考虑的问题——
(1)封装
(2)设计API
(3)选择具体的算法和数据类型
(4)选择实现的接口(一般是功能性接口)
(5)选择继承的类(多态)
(6)字符串的表示习惯(重写Object类的toString()方法)
(7)考虑使用的基本类型的包装类型
(8)等价性(重写Object类的equals()方法和hashCode()方法)
(9)考虑使用时的内存管理与空指针问题。
(10)是否将类设计为不可变类(不提供改变属性值的方法)。
(11)契约式设计——在Java中是异常(Exception)和断言(Assertion)。

三.数据抽象的具体实例——背包、队列和栈
许多基础数据类型都和对象的集合有关。具体来说，数据类型的值就是一组对象的集合。
(1)Bags背包是一种不支持从中删除元素的集合数据类型——其目的就是帮助用例收集元素并迭代遍历所有收集的元素。无序且可重复。
(2)Queue先进先出队列是一种基于先进先出(FIFO)策略的集合类型。使用队列集合的主要原因是保存元素的同时保存它们的相对顺序:使它们入列顺序和出列顺序相同有序且重复
(3)Stack下压栈是一种基于后进先出(LIFO)策略的集合类型。其保存元素的同时颠倒其相对顺序。有序且重复

 三个目标——
    (1)说明对集合中的对象的表示方式将直接影响各种操作的效率。
    (2)介绍泛型和迭代。
    (3)说明链式数据结构的重要性。

 学习步骤(也是全书的学习步骤)——
    (1)学习其API和用例(实现一份API的第一步就是选择数据的表示方式)。
    (2)讨论数据类型的值的所有可能的表示方法。
    (3)数据类型的各种操作的实现。
    需要做成可迭代的。

 集合数据的类型的实现整个逻辑
    定容栈——>泛型——>调整数组大小——>对象游离问题——>迭代
 链表
    结点记录——>构造链表——>不同位置插入元素——>遍历

 综述——
    (1)拥有两种表示对象集合的方式——数组和链表。两者都非常基础，也被称为顺序存储和链式存储。
    (2)之后会介绍的各种抽象数据结构都是基于bags、queue、stack这些基本数据类型组合而成的。
    (3)首先学习这三种基本数据结构的原因——
        ①将以这些数据类型为基石构造本书中的其他更高级的数据结构;
        ②展示了数据结构和算法的关系以及同时满足多个有可能相互冲突的性能目标时所要面对的挑战;
        ③我们将要学习的若干算法的实现重点就是需要其中的抽象数据类型能够支持对对象集合的强大操作。

 方法论——在研究一个新的应用领域时，我们将会按照以下步骤识别目标并使用数据抽象解决问题:
        ①定义API;
        ②根据特定的应用场景开发用例代码;
        ③描述一种数据结构(一组值的表示),并在API所对应的的抽象数据类型的实现中根据它定义类的实例变量(成员变量);
        ④描述算法(实现一组操作的方式)，并根据它实现类中的实例方法;
        ⑤分析算法的性能特点。

 常用数据结构的组合——
        父链接树——整型数组
        二分查找树——含有两个链接的结点
        字符串——数组、偏移量和长度
        二叉堆——对象数组
        散列表(拉链法)——链表数组
        散列表(线性探测法)——两个对象数组
        图的邻接链表——Bag对象的数组
        单词查找树——含有链接数组的结点
        三向单词查找树——含有三个链接的结点

四.算法分析
 概念
    使用数学分析为算法成本建立简洁的模型并使用实验数据验证这些模型。
 科学方法
    (1)细致地观察真实世界的特点，通常还要有精确的测量;
    (2)根据观察结果提出假设模型;
    (3)根据模型预测未来的事件;
    (4)继续观察并核实预测的准确性;
    (5)如此反复知道确认预测和观察一致。
    科学方法的根本就是可重现与可证伪。

 步骤
    (1)观察——
        如何定量测量程序的运行时间——计算性任务的困难程度可以用问题的规模(可以是输入的大小或是某个命令行参数的值)来衡量。
    如何更好的将问题规模和运行时间的关系量化。
        程序在不同的计算机上的运行时间之比通常是一个常数。
        计时器——>实验数据的分析——>猜想——>得到运行时间关于输入规模N的函数
    (2)数学模型
        D.E.Knuth认为，尽管有许多复杂的因素影响着我们对程序的运行时间的理解，原则上我们仍然可能构造出一个数学模型来描述
    任意程序的运行时间。这种观点被抽象为简单的两点——程序运行的总时间主要和这两点有关——
        ①执行每条语句的耗时——取决于计算机、Java编译器和操作系统。
        ②执行每条语句的频率——取决于程序本身和输入。
        如果对于程序的所有部分我们都知道了这两个性质，我们就可以将它们相乘并将程序中所有指令的成本相加得到总运行时间。所
    以我们着重分析的是每条语句的执行频率(即可能的执行次数)。它可能与输入数据有关，适当时还需要用上概率分析。
        当分析出现复杂冗长的数学表达式时，我们需要学会取近似值。使用"～"来表达近似。

        增长数量级——近似之后剩下的主要的数学表达式部分。增长数量级将程序和它实现的算法隔离开来了。即算法(有时还要算上
    输入模型)决定了其增长数量级。将算法和某台计算机上的具体实现分离开来是一个强大的概念。

        另一个观察——执行最频繁的指令决定了程序执行的总时间——我们将这些指令称为程序的内循环。许多程序的运行时间都只取
    决于其中的一小部分指令。

        算法的分析
            成本模型——即以哪些代码来作评估量的参考(如访问数组的次数等)。
            通过明确成本模型使给定实现所需的运行时间的增长数量级和它背后的算法成本的增长数量级相同(换句话说，成本模型应
        该和内循环中的操作有关！！)

        书中约定——
            ①性质表示需要用实验验证的猜想。
            ②命题表示在某个成本模型下算法的数学性质——即研究一个算法的前提是确定研究所基于的成本模型。
            我们研究算法准确的数学性质(命题)并对实现的性能做出猜想(性质)，可以通过实验验证这些猜想。

        总结——
            对于大多数程序，得到其运行时间的数学模型所需步骤如下——
            ①确定输入模型，定义问题的规模;
            ②识别内循环;
            ③根据内循环中的操作确定成本模型;
            ④对于给定的输入，判断这些操作的执行频率。

        在算法分析中进行数学建模是一个多产的研究领域。理解特定的数学模型对于理解基础算法的运行效率是很关键的。

    (3)增长数量级的分类
        ①常数级别——普通语句——最简单的两数相加
        ②对数级别——二分策略——二分查找
        ③线性级别——循环——找出最大元素
        ④线性对数级别——分治——归并排序
        ⑤平方级别——双层循环——检查所有元素对
        ⑥立方级别——三层循环——检查所有三元组
        ⑦指数级别——穷举查找——检查所有子集

    (4)设计更快的算法
        学习程序的增长数量级的一个重要动力是为了帮助我们为同一个问题设计更快的算法。

        尽量将各种基础问题的解决方法向对数级别、线性级别或是线性对数级别靠。

        为算法在最坏情况下的运行时间给出一个下界的思想是非常有意义的。复杂的下界是很难找到的，但它非常有助于指引我们追求
    更加有效的算法。

        在本书中，我们会按照以下方式解决各种新问题——
        ①实现并分析该问题的一种简单解法——即暴力算法
        ②考察算法的各种改进，通常都能降低算法所需的运行时间的增长数量级。
        ③用实验证明新的算法更快。

    (5)倍率实验
        一种简单有效预测任何程序的性能并判断它们运行时间大致的增长数量级的方式——
        每次输入数据规模变大一个比例(一般为两倍，即第一次输入数据为N，则第n次输入数据为nN)，然后计算每次实验和上一次实验
    运行时间的比值。反复运行知道该比值趋近于2的指数结果。
        这个实验对于比值没有极限的算法无效。
        做这个实验的时候，需要考虑——
        ①评估解决大型问题的可行性。
        “该程序能在可接受的时间内处理这些数据吗？”对于大量数据，我们可能需要一个比乘以2更大的系数。
        ②评估使用更快计算机所产生的价值。
        “如果我能够得到一台更快的计算机，解决问题的速度能够加快多少？”
        如果使用的是平方或者立方级别的算法，摩尔定律就不适用。进行倍率测试并检查随着输入规模的倍增前后运行时间之比是趋向
        于2而非4或8即可验证这种情况。

    (6)算法分析中需要注意的事项
        ①大常数——保持对大常数的敏感性，别轻易忽略。
        ②非决定性的内循环
        ③指令时间——每天指令所需的时间总是相同的假设并不总是正确。如缓存技术。
        ④系统因素——如抢占进程等。可能会干涉到实验的可重现这条原则。
        ⑤不分伯仲
        ⑥对输入的强烈依赖
        ⑦多个问题参量——之前的分析大多只考虑了一个参量，如输入规模或命令行参数。

        完整精确的分析组好留给专家，但相同的方法可以让我们有效地近似估计出任何程序所需的运行时间。

    (7)处理对于输入的依赖
        ①输入模型
            主要困难两点——
            输入模型可能是不切实际的;
            对输入的分析可能极端困难，所需的数学技巧远非一般的学生或程序员所能掌握。
        ②对最坏情况下的性能的保证
            有些应用程序要求程序对于任意输入的运行时间均小于某个指定的上限。做保守估计，找到程序边界。
        ③随机化算法
            为性能提供保证的一种重要方法是引入随机性。通过加入随机性后，可以模拟真实的情况，同时让一些算法保持更低运算
        量算法级别。
        ④操作序列
            操作的顺序不同。如stack的入栈出栈顺序。
        ⑤均摊分析
            通过记录所有操作的总成本并除以操作综述来将成本均摊。这样我们可以允许一些昂贵的操作，同时也保持了所有操作的平
        均成本较低。
            将少量昂贵操作的成本通过各种大量廉价的操作摊平。

         算法分析者的任务就是尽可能地揭示关于某个算法的更多信息，而程序员的任务则是利用这些信息开发有效解决现实问题的程
         序。

    (8)内存
        分析内存的使用比分析程序所需的运行时间要简单得多，主要原因是他所涉及的程序语句较少(只有声明语句)且在分析中我们会
    将复杂的对象简化为原始数据类型，而原始数据类型的内存使用是预先定义好的，而且非常容易理解:只需将变量的数量和它们的类
    型所对应的字节数分别相乘并汇总即可。如Java的int是8字节32位这种。

    (9)综述——展望
        良好的性能是非常重要的。速度极慢的程序和不正确的程序一样无用。所以有必要在一开始就关注程序的运行成本，并时刻关注
    程序中的内循环代码的组成。

        ①编程领域，最常见的错误或许就是过于关注程序的性能。你的首要任务应该是写出清晰正确的代码。仅仅为了提高运行速度而
    修改程序的事最好留给专家们来做。另外如果降低成本带来的效益并不明显，那么对运行时间的改进就不值得了。
        ②另一个极端，完全忽略了程序的性能。较快的算法一般都比暴力算法更复杂，所以很多人宁可使用较慢的算法也不愿应付复杂
    的代码。当我们需要处理大规模问题时，通常除了寻找更好的算法之外我们别无选择。

        总体步骤——
       (1)完整而详细地定义问题，找出解决问题所必需的基本抽象操作并定义一份API。
       (2)简洁地实现一种初级算法，给出一个精心组织的开发用例并使用实际数据作为输入。
       (3)当实现所能解决的问题的最大规模达不到期望时决定改进还是放弃。
       (4)逐步改进实现，通过经验性分析或(和)数学分析验证改进后的效果。
       (5)用更高层次的抽象表示数据结构或算法来设计更高级的改进版本。
       (6)如果可能尽量为最坏情况下的性能提供保证，但在处理普通数据时也要有良好的性能。
       (7)在适当的时候将更细致的深入研究留给有经验的研究者并继续解决下一个问题。