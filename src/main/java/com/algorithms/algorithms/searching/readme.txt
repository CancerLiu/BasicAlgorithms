查找(searching)
        一.符号表
            1.符号表
                (1)定义
                符号表最主要的目的就是将一个键和一个值联系起来(即键值对的数据结构)。其支持两种操作:插入(put)——将一组新的键
            值对存入表中;查找(get)——根据给定的键得到相应的值。
                (2)设计符号表数据结构时需要考虑的问题
                ①泛型——不像优先队列那样将键和元素(值)混为一谈，。
                ②重复的键——遵循如下规则:①每个键只对应着一个值(不允许重复的键);②当用例代码向表中存入的键值对和表中已有
                               的键(及关联的值)冲突时，新的值会替代旧的值;
                ③空(null)键——键不能为空;
                ④空(null)值——值不能为空;
                ⑤删除操作——延时删除(将键对应的值为空，然后在某个时候删去所有值为空的键)和即时删除(立即从表中删除指定键);
                ⑥便捷方法;
                ⑦迭代方法——返回一个范围内所有的键的迭代器(有序符号表);
                ⑧键的等价性——最好使用不可变的数据类型作为键，否则表的一致性无法保证。

            2.有序符号表
                (1)定义
                所谓有序符号表就是符号表中的的键是有下标索引的，我们可以根据这些索引来对键进行排序。
                (2)设计有序符号表时候额外需要考虑的问题——
                    ①最大键与最小键——和优先队列相比，优先队列中可以存在重复的键但符号表中不行;
                    ②向下取整和向上取整——floor与ceiling;
                    ③排名和选择——有序符号表中，检验一个新的键是否插入合适位置的基本操作是排名(rank，找出小于指定键的键的数量);
                                     选择(select，找出排名为k的键)。
                                     如果有序符号表中的键有序，则对从从0到size()-1的所有i都有i==rank(select(i))，且所有的键都满足
                                     key==select(rank(key));
                                     对于符号表，我们的挑战是在实现插入、删除和查找的同时快速实现这两种操作。
                    ④范围查找——给定范围内(在两个给点的键之间)，有多少键?是哪些?
                    ⑤例外情况——当一个方法需要返回一个键但表中却没有合适的键可以返回的时候，我们约定抛出一个异常(另一种合理的
                                   方法是在这种情况下返回空)。
                    ⑥便捷方法;
                    ⑦(再谈)键的等价性——所有键需要同时满足equals()和comareTo()相等。
                    ⑧成本模型
                        比较——这里使用比较一次表示将一个符号表条目和一个被查找的键进行比较操作;
                        查找的成本模型——学习符号表时，我们会统计比较的次数(等价性测试或是键的相互比较)。在内循环不进行比较(极
                                          少)的情况下，我们会统计数组的访问次数。

                        符号表实现的重点在于其中使用的数据结构和get()、put()方法。

            3.符号表的用例测试——
                处理大型数据时，符号表可能面对的操作和由此产生的相应问题——
                (1)混合使用查找和插入的操作;
                (2)大量的不同键;
                (3)查找操作比插入操作多得多;
                (4)虽然不可预测，但查找和插入操作使用模式并非随机。

            4.无序链表中的顺序查找
                (1)概念
                符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对。此种数据结构的get()和put()方法都是基
            于顺序查找(在查找中我们一个一个地顺序遍历符号表中的所有键并使用equals()方法来寻找与被查找的键匹配的键)。

                命题——①在含有N对键值的基于(无序)链表的符号表中，未命中的查找和插入操作都需要N次比较。命中的查找在最坏
                       情况下需要N次比较。
                      ②特别的，向一个空表中插入N个不同的键需要～(Ne2)/2次比较。

                (2)分析
                    ①分析符号表算法比分析排序算法更困难，因为不同的用例所进行的操作序列各不相同。最常见的情形是虽然查
                     找和插入的使用模式是不可预测的，但它们的使用肯定不是随机的。主要是研究最坏情况下的性能。
                  ★②查找的一种度量方式是查找表中的每个键，并将总时间除以总数量N。在查找表中的每个键的可能性都相同的情
                     况下时，这个结果就是一次查找平均所需的比较数，我们将之称为"随机命中"。
                    ③基于链表的实现以及顺序查找是非常低效的。比较的总次数和查找次数与插入次数的乘积成正比。

            5.有序数组中的二分查找
                (1)概念
                    其数据结构是基于一对平行数组(即一组数组，每个数组存对象的一个属性)、一个存储键一个存储值。

                    这份实现的核心是rank()方法，因为是有序的，所以可以靠这个方法建立起键和值的关系。

                    插入时，将所有更大的键向后移动一格来腾出位置(从后向前)。

                (2)命题——①在N个键的有序数组中进行二分查找最多需要(lgN+1)次比较(无论成功与否)。
                          ②向大小为N的有序数组中插入一个新的元素，在最坏情况下需要访问～2N次数组，因此向一个空符号中
                            插入N个元素在最坏情况下需要访问～Ne2次数组。

                (3)分析——二分查找减少了比较的次数但无法减少运行所需时间。因为在构造一个基于数组的符号表所需要访问数组的
                          次数是数组长度的平方级别(在实际情况下键的排列虽然不是随机的，但仍然很好地符合这个模型)。



                为什么符号表不像优先队列那样使用一个Comparable的Item类型，而是对于键和值使用不同的数据类型?
                答:这的确是一种可行的办法。这两者代表了将键和值关联起来的两种不同方式——我们可以构造一种将键包含在其中
                   的数据结构来隐式关联键或是显式地将键和值区分开来。对于符号表，我们选择突出关联数组的抽象形式。同时也
                   请注意，符号表的用例在查找时只会指定一个键，而非一个键值对。

        二.二叉查找树
            1.基本概念
               (1)二叉树能够将链表插入的灵活性和有序数组查找的高效性结合起来。一棵二叉查找树相对于链表来说含有两个链接。
               (2)父结点、左子结点、右子结点、左链接、右链接、子二叉树
               (3)定义————一棵二叉查找树(BST)是一颗二叉树，其中每个结点都含有一个Comparable的键(以及相关联的值)且每个结点的键都大于
                          其左子树中的任意结点而小于右子树的任意结点的键。

            2.设计普通二叉查找树时需要考虑的与基本实现
               (1)数据表示
                    每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器(给出以该结点为根的子树的结点总数)。

                    一棵二叉查找树代表了一组键(及其相应的值)的集合，而同一个集合可以用多棵不同的二叉查找树表示。这展示了二叉查找树的
                    灵活性。
               (2)查找
                    命中与非命中,大于当前(子)树根节点，则右子树查找，否则左子树查找————搜索路径。
               (3)插入
                    二叉查找树的另一个更重要的特性就是插入的实现难度和查找差不多。和查找类比，插入之前先要查找，如果查找到返回null,
                    则在此处插入新键值，并返回一个含有该键值的新结点。如果是更新，则返回被更新的结点。
               (4)递归
                    在二叉查找树中,可以将递归调用前的代码想象成沿着树向下走:它会将给定的键和每个结点的键相比较并根据结果向左或者向右
                    移动到下一个结点;然后可以将递归调用后的代码想象成沿着树向上爬————对于get()方法，其对应着一系列的返回指令(return),
                    但是对于put()方法,这意味着重置搜索路径上每个父结点指向子结点的链接，并增加路径上每个结点中的计数器的值。


            3.分析
               (1)使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。最好的情况(完全平衡二叉树)其查
                  找次数~lgN，最坏的情况(此时二叉树退化为了链表)其查找次数可能是N。

               (2)命题————①在由N个随机键构造的二叉查找树中,查找命中平均所需的比较次数为~2lnN(约1.39lgN)。
                          ②在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为~2lnN(约1.39lgN)。
                          说明二叉查找树中查找随机键的成本比二分查找高约39%。

            4.在第2点的基础上加上有序性时需要考虑的问题
               二叉查找树的一个特点就是其能够保持键的有序性。这使得符号表的用例不仅能够通过键还能通过键的相对顺序来访问键值对。
               (1)最大键和最小键
                    如果根结点的左链接为空，那么最小的键就是根结点;如果左链接非空,那么树中的最小键就是左子树中的最小键。最大键类似。

               (2)向上取整和向下取整
                    如果给定的键key小于二叉查找树的根结点的键,那么小于等于key的最大键floor(key)一定在根结点的左子树中;如果给定的键
                    key大于二叉查找树的根结点,那么只有当根结点右子树中存在小于等于key的结点时,小于等于key的最大键才会出现在右子树中,
                    否则根结点就是小于等于key的最大键。ceiling()的算法类似。

               (3)选择操作(select(...))
                    每个结点所维护的子树结点计数器变量N就是用来支持此操作的。假设我们想找到排名为k的键(即树中正好有k个小于它的键)。
                    如果左子树中的结点数t大于k,那么我们就继续(递归地)在左子树中查找排名为k的键;如果t等于k,我们返回根结点中的键;如果
                    t小于k,我们就(递归地)在右子树中查找排名(k-t-1)的键。

               (4)排名(rank(...))
                    rank()是select()的逆方法,它会返回给定键的排名。它的实现和select()类似。
                    如果给定的键和根结点的键相等,我们返回左子树中的结点总数t;如果给定的键小于根结点,我们会返回该键在左子树中的排名
                    (递归计算);如果给定的键大于根结点，我们会返回t+1(根结点)加上它在右子树的排名(递归计算).

               (5)删除最大键和最小键
                    deleteMin()方法————我们约定该方法接受一个指向结点的链接,并返回一个指向结点的链接.
                    具体而言,我们需要不断深入根结点的左子树中直至遇见一个空链接，然后将指向该结点的链接指向该结点的右子树(只需要在递
                    归中返回它的右链接即可)。此时已经没有任何链接指向要被删除的结点,因此它会被GC。

               (6)删除操作
                    相比与(5),这里主要是删除一个含有两个子结点的结点后该如何处理————
                    简单来说就是删除结点后,用它的后继结点进行替换。具体步骤如下(x是待删除的结点):
                    ①将指向即将被删除的结点的链接保存为t;
                    ②将x指向它的后继结点min(t.right);
                    ③将x的右链接(原本指向一棵所有结点都大于x.key的二叉查找树)指向deleteMin(t.right)(deleteMin(...)方法返回的是
                     删除结点所对应的根结点链接),也就是在删除后所有结点仍然大于x.key的子二叉查找树.
                    ④将x的左链接(本为空)设为t.left(其下所有的键都小于被删除的结点和它的后继结点)。

               (7)范围查找
                    要实现能够返回给定范围内键的keys()方法,我们首先需要一个遍历二叉查找树的基本方法.具体二叉查找树的遍历分为前序遍历、
                    中序遍历和后序遍历。具体如下————
                    前序遍历————首先访问根结点然后遍历左子树，最后遍历右子树;
                    中序遍历————首先遍历左子树，然后访问根结点，最后遍历右子树;
                    后序遍历————首先遍历左子树，然后遍历右子树，最后访问根结点;

                    为了确保以给定为根的子树中所有的指定范围之内的键加入队列,我们会递归地按上述相关遍历逻辑遍历数组。

            5.最终的性能分析(加上有序性之后)
               (1)给定一棵树,树的高度决定了所有操作再最坏情况下的性能(范围查找除外,因为它的额外成本和返回的键的数量成正比).

               (2)命题————在一棵二叉查找树中，所有操作在最坏情况下所需的时间和树的高度成正比.

        三.平衡查找树
            前面说了三种符号表的实现方式,分别是无序的链表结构实现、有序的数组结构实现和二叉树数据结构实现。二叉树实现时最主要的问题在
            于,创建二叉树时如果不平衡,就会导致在最坏的情况下性能很糟糕。所以这里的平衡查找树一章主要就是为了能够保持二叉树查找树的平
            衡性。


            1.2-3树
                (1)定义————
                    一棵2-3查找树或为一棵空树,或由以下结点组成:
                    2-结点,含有一个键(及其对应的值)和两条链接，左链接指向的2-3树中的键都小于该结点,右链接指向的2-3树中的键都大于改
                    结点。
                    3-结点,含有两个键(及其对象的值)和三条链接,左链接指向的2-3树中的键都小于该结点,中链接指向的2-3树的键都位于该结点
                    的两个键之间,右链接指向的2-3树中的键都大于该结点。
                    最后,我们指向一棵空树的链接称为空链接。

                    一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。

                (2)2-3树的查找
                    和二叉树类似,只不过不是简单的左右子树而是有三个子区间.

                (3)插入
                    平衡查找树和二叉查找树最大的区别就在于,其在插入的时候可以保证平衡。因为平衡查找树的一个结点可以允许放两个键,且多
                    出了一个链接。所以放元素的时候,可以避免树最终退化为一个链表。

                    ①向2-结点中插入新键
                        插入后将这个2-结点替换为一个3-结点,将要插入的键保存在其中即可。

                    ②向一棵只含有一个3-结点的树中插入新键
                        简言之就是先临时构造一棵4-结点树,然后再将之转换为一棵由3个2-结点组成的2-3树。转换后,其中一个结点(根)含有中
                        键,一个结点(左)含有3个键中的最小者,一个结点(右)含有3个键中的最大者。同时整棵树的高度会+1.

                    ③向一棵父结点为2-结点的3-结点中插入新键
                        主要思路是在维持树的完美平衡的前提下为新键腾出空间。我们仍向刚才一样,构造一个临时的4-结点并将其分解,但此时
                        我们不会为中键创建一个新结点,而是将其移动至原来的父结点中。这次转换后,原来指向原3-结点的一条链接被替换为了
                        新父结点中的原中键左右两边的两条链接,并分别指向两个新的2-结点。

                    ④向一个父结点为3-结点的3-结点中插入新键
                        类比③,再将底层的3-结点的中键转换到父结点的时候,父结点本身也是一个3-结点了,此时我们继续将该层的中间往其父结点
                        转换。重复该操作知道遇到一个2-结点的父结点。

                (4)分解根结点
                    接(3),如果一直往父结点传递中键,直到根结点还是一个3-结点,此时我们就要分解根结点。将之分解为3个2-结点。此时整棵树
                    的高度会+1.

                (5)局部变换
                    将一个4-结点分解为一棵2-3树可能有6种情况。具体看这个4-结点的位置,其可能是根结点,可能是一个2-结点的左子结点或者
                    右子结点,也可能是一个3-结点的左子结点、中子结点或者右子结点。
                    2-3树的插入算法的根本在于这些变换都是局部的:除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中,变
                    更的链接数量不会超过一个很小的常数。

                (6)全局性质
                    类比如果发生了(4)中的分解根结点的现象,则会让树的高度+1。此时会影响的整棵树的全局性质。
                    和标准的二叉查找树由上向下生长不同,2-3树的生长是由下向上的。

                命题————在一棵大小为N的2-3树中,查找和插入操作访问的结点必然不超过lgN个。

                2-3树可以解决二叉查找树的不平衡的缺点,但是其数据结构并不容易实现或实现后不便于操作。所以这里引入红黑二叉查找树.


            2.红黑二叉查找树

                红黑二叉查找树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。

                (1)定义
                我们将书中的链条分为两种类型————红链接将两个2-结点连接起来构成一个3-结点。
                                             黑链接则是2-3树中的普通链接。
                即我们将3-结点表示为由一条左斜的红色链接(两个2-结点其中之一是另一个的左节点)相连的两个2-结点。这样对于任意的2-3树,
                只要对结点进行转换,我们都可以立即派生出一棵对应的二叉查找树。

                另一种等价的定义————
                    红链接均为左链接;没有任何一个结点同时和两条红链接相连;该树是完美黑色平衡的,即任意空链接到根结点的路径上的黑链接
                    数量相同。

                综上,一棵红黑树既是二叉查找树也是2-3树。此时我们就可以将两个算法的有点结合起来:二叉查找树中简洁高效的查找方法和2-3树
                中高效的平衡插入算法。

                这里约定,一个结点的颜色,指从其父结点指向该结点的链接的颜色。


                (2)旋转
                    旋转操作主要是用于保证2-3树和红黑树之间的一一对应关系,因为旋转操作可以保持红黑树的两个重要性质————有序性和完美平
                    衡性。也就是再红黑树中进行旋转时,我们无需为树的有序性或者完美平衡性担心。

                    旋转主要发生在(1)中的"另一种等价的定义"中在的第一和第二点不满足时,即在红色右链接或者连续两条红链接的时候发生旋转。

                    具体以左旋转为例说明整体逻辑————
                        将A父结点的右子结点B当作父结点,B的左子结点当作A的右子结点。左旋转完成。

                (3)插入
                    上述的(2)旋转一般在插入后进行。这里约定插入的键和其父结点都是通过红链接相连。
                    ①向单个2-结点中插入新键
                        如果新键小于老键,则只需要新增一个红色的结点即可;如果新键大于老键,那么新增的红色结点将会产生一条红色的右链接,
                        此时我们需要左旋转结点即可。
                    ②向树底部的2-结点插入新键
                        和①中很相像,插入后会在树的底部新增一个结点。这里总是会用红链接将新结点和它的父结点相连。如果该结点是父结点的
                        左链接,则父结点就直接成为了一个3-结点;否则需要对父结点进行左旋。
                    ③向一棵双键树(即一个3-结点)中插入新键
                        此时分为三种情况,插入的键小于存在的两个键,在存在的两个键之间和大于存在的两个键.

                        大于————此时新键在存在两键中较大键的右子结点。此时将两条红链接变为黑链接即可;
                        小于————此时新键在存在两键中较小键的左子结点。此时对两键中的较大结点右旋转后转为"大于"情况;
                        中间————此时新键在存在两键中较小键的右子结点。此时对较小结点进行左旋转,然后转换为"小于"情况。

                    ④向树底部的3-结点插入新键
                        在底部的3-结点中,其情况和③中相同。唯一多的一步操作就是,在③中的"大于"情况中,两个链接从红遍黑时,该树指向父结
                        点的链接由黑变红。这意味着在父结点中继续插入了一个新键。


                    结合③和④我们就可以在树中将红链接向上传入,类似于2-3树中插入时的局部变换。

                    根结点总是黑色的(每次插入时都会将根结点设置为黑色),根结点由红变黑的时候,树的黑链接高度就会+1.

                (4)删除
                    和插入操作一样,我们也可以定义一系列局部变换来在删除一个结点的同时保持树的完美平衡性。这个过程比插入一个结点更加
                    复杂,因为我们不仅要在(为了删除一个结点而)构造临时4-结点时沿着查找树路径向下进行变换,还要在分解遗留的4-结点时沿着
                    查找路径向上进行变换(同插入操作)。

                    ①删除最小键
                        这里删除主要是为了避免从2-结点中删除一个键,留下一个空结点(空链接)时,破坏树的完美平衡性。
                        最小键一定在树的左子树的左链接中。在沿着左链接向下的过程中,保证以下情况之一成立:

                        如果当前结点的左子结点不是2-结点,直接删除,完成;

                        如果当前结点的左子结点是2-结点,而它的亲兄弟结点不是2-结点,将左子结点的兄弟结点中的一个键移动到左子结点中;

                        如果当前结点的左子结点和它的亲兄弟结点都是2-结点,将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为
                        4-结点,使父结点由3-结点变为2-结点或者由4-结点变为3-结点.

                        在遍历的过程中执行这个过程,最后能够得到一个含有最小键的3-结点或者4-结点,然后我们就可以直接从中将其删除,将3-
                        结点变为2-结点,或者将4-结点变为3-结点。然后我们再回头向上分解所有临时的4-结点。

                    ②删除操作
                        在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是2-结点。如果被查找的键在树的
                        底部,我们可以直接删除它。如果不在,我们需要将它和它的后继结点交换,就和二叉查找树一样。删除之后我们需要向上回
                        溯并分解余下的4-结点。

                (5)红黑树的性质
                    研究红黑树的性质就是要检查对应的2-3树并对相应的2-3树进行分析。

                    所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别(范围查找除外,它所需的额外时间和返回的键的数量成正比)。

                    命题————①一棵大小为N的红黑树的高度不会超过2lgN————红黑树的最坏情况是它所对应的2-3树中构成最左边的路劲结点全部都
                             是3-结点而其余均为2-结点。
                            ②一棵大小为N的红黑树中,根结点到任意结点的平均路径长度为~1.00lgN。

                            红黑树的get()方法不会检查结点的颜色,因此平衡性相关的操作不会产生任何负担;因为树是平衡的,所以查找比二叉
                            查找树更快。每个键只会被插入一次,但却可能被查找无数次,因此最后我们只用了很小的代价(和二分查找不同,我们
                            可以保证插入操作是对数级别的)就取得了和最有情况近似的查找时间(因为树是接近完美平衡的,且查找过程中不会进
                            行任何平衡性的操作)。

                            红黑树最吸引人的一点是它的实现中最复杂的代码仅限于put()(和删除)方法。二叉查找树中的查最大和最小键、
                            select()、rank()、floor()、ceiling()和范围查找方法不做任何变动即可继续使用,因为红黑树也是二叉查找树
                            而这些操作也不会涉及结点的颜色。所以这些方法都能从红黑树近乎完美的平衡性中受益。

                    命题————在一棵红黑树中,以下操作在最坏情况下所需的时间是对数级别的:查找(get())、插入(put())、查找最小键、查找最
                            大键、floor()、ceiling()、rank()、select()、删除最小键(deleteMin())、删除最大键(deleteMax())、删
                            除(delete())和范围查询(range())。

                (6)综述
                    目前符号表的各种实现如下————
                    ①顺序查询(无序链表)
                    ②二分查找(有序数组)
                    ③二叉查找树(BST)
                    ④2-3树查找(红黑树)

        四.散列表
            如果所有的键都是小整数,我们可以用一个数组来实现无序的符号表,将键作为数组的索引而数组中键i处储存的就是它对应的值。这样我们
            就可以快速访问任意键的值。"将键作为数组的索引"的实现我们主要是通过算数操作来实现的,即将键转化为数组的索引来访问数组中的键
            值对。

            使用散列的查找算法分为两步。第一步是用散列函数将查找的键转化为数组的一个索引————理想情况下,不同的键都能转化为不同的索引值。
            如果出现相同的索引,则需要考虑第二步;第二步是一个处理碰撞冲突的过程,主要有两种解决碰撞的方法————拉链法和线性探测法。

            散列表是算法在时间和空间上做出权衡的经典例子。使用适度的空间和时间并在这两个极端之间找到一种平衡。具体来说只需要调整散列算
            法的参数就可以在空间和时间之间做出取舍。

            使用散列表可以实现在一般应用中拥有(均摊后)常数级别的查找和插入操作的符号表。

            1.散列函数
                (1)定义
                    散列函数的计算,这个过程会将键转化为数组的索引。如果我们有一个能保存M个键值对的数组,那么我们就需要一个能够将任意键
                    转化为该数组范围内的索引([0,M-1]范围内的整数)的散列函数。

                    特点————易于计算;能够均匀分布所有的键。

                (2)典型
                    散列函数和键的类型有关。严格地说,对于每种类型地键我们都需要一个与之对应地散列函数。对于许多常见类型的键,我们可以
                    利用Java提供的默认实现。同时我们也可以在此基础上自定义实现散列函数。

                    ①正整数
                        整数散列最常用的方法是 除留余数法————我们选择大小为素数M的数组,对于任意正整数k,计算k除以M的余数(k%M),这个
                        方法能够有效地将键散布在0到M-1的范围内。
                        如果M不是素数,我们可能无法利用键中包含的所有信息,这可能导致我们无法均匀地散列散列值。

                    ②浮点数
                        如果键是0~1之间的实数,我们可以将它乘以M并四舍五入得到一个0至M-1之间的索引值。但是这种方法是有缺陷的,因为这
                        种情况下键的高位起的作用更大,最低位对散列的结果没有影响。
                        修正的方式是将键表示为二进制数(此时每一位的作用都一样了)然后再使用除留余数法。

                    ③字符串
                        int hash = 0;
                        for (int i = 0; i<s.length(); i++)
                            hash = (R * hash + s.charAt(i)) % M;
                        主要R足够小,不造成溢出。

                    ④组合键
                        如果键的类型含有多个,我们可以如③中的String类型一样将它们混合起来计算得到一个散列值。以Date自定义类为例————

                        int hash = (((day * R + month) % M) * R + year) % M
                        只要R足够小不造成溢出

                (3)Java中的约定
                    Java令所有的数据类型都继承了一个能够返回一个32比特整数的hashCode()方法。注意每一种hashCode()方法都必须和其
                    equals()方法一致。如果equals()方法相同,hashCode()方法不同,则会发生哈希碰撞,需要进一步处理。

                    因为我们需要的是数组的索引而不是一个32位的整数,我们在实现中会将默认的hashCode()方法和除留余数法结合起来产生一个
                    0到M-1的整数,方法如下————
                        private int hash(Key x){
                            return (x.hashCode() & 0x7fffffff) % M;
                        }
                        0x7fffffff为十六进制,其二进制表示的是除了首位为0其余全是1的最大int型(有符号)。
                        一般会将数组的大小M取为素数以充分利用原散列值的所有位。

                (4)综述
                    如果散了值的计算很耗时,那么我们或许可以将每个键的散列值缓存起来。

                    总的来说,要为一个数据类型实现一个优秀的散列方法需要满足三个条件:
                    一致性————等价的键必然产生相等的散列值;
                    高效性————计算简便;
                    均匀性————均匀地散列所有地键。

                    有性能要求时应该谨慎使用散列。保证均匀性的最好办法也许就是保证键的每一位都在散列值的计算中起到相同的作用:实现散列
                    函数最常见的错误也许就是忽略了键的高位。


                (5)命题————(均匀散列假设)我们使用的散列函数能够均匀并独立地将所有地键散布于0~M-1之间。

            2.基于拉链法的散列表
                如前所知,拉链法是用于处理哈希碰撞的问题而产生的。

                (1)定义
                    将大小为M的数组中的每个元素指向一条链表,链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法被称为拉链
                    法。冲突的元素都被存储在了链表中。

                    具体查找一个键的值时,分为两步:首先根据散列值找到对应的链表;然后沿着链表顺序查找相应的键。

                (2)命题与性质
                    命题————在一张含有M条链表和N个键的散列表中,(假设J成立的前提下)任意一条链表中的键的数量均在N/M的常数因子范围内的
                    概率无限趋向于1。

                    性质————在一张含有M条链接和N个键的散列表中,未命中查找和插入操作所需的比较次数为~N/M。

                    大量经验丰富的程序员给出的应用实例令我们确信,在基于拉链法的散列表中使用大小为M的数组能够将查找和插入操作的效率提
                    高M倍。

                (3)散列表的大小
                    在实现基于拉链法的散列表时,我们的目标是选择适当的数组大小M,既不会因为空链接表而浪费大量内存,也不会因为链表太长而
                    在查找上浪费太多时间。
                    而拉链法的一个好处就是这并不是关键性的选择。如果存入的键多于预期,查找所需的时间只会比选择更大的数组稍长;如果少于
                    预期,虽然有些空间浪费但查找会非常快。所以当内存不是很紧张时,可以选择一个足够大的M,使得查找需要的时间变为常数;当
                    内存紧张时,选择尽量大的M仍然能够将性能提高M倍。

                    另一种方法是动态调整数组的大小以保持短小的链表。

                (4)删除操作
                    先查找再删除。

                (5)有序性相关的操作
                    散列最主要的目的在于均匀地将键散布开来,因此在计算散列后键的顺序信息就丢失了。所以对于和顺序相关的操作(如找最大最
                    小值或某个范围的值等),散列表都不是合适的选择,因为这些操作的运行时间都将会是线性的。

                (6)综述
                    基于拉链法的散列表实现简单。在键的顺序并不重要的应用中,它可能是最快的(也是使用最广泛的)符号表实现。

            3.基于线性探测法的散列表
                实现散列表的另一种方式就是用大小为M的数组保存N个键值对,其中M>N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的
                所有方法被统称为开放地址散列表。

                开放地址散列表中最简单的方法叫做线性探测法。

                (1)定义
                    当碰撞发生时(当一个键的散列值已经被另一个不同的键占用),我们直接检查散列表中的下一个位置(将索引值+1)。

                    线性探测可能会产生三种结果————
                    命中:该位置的键和被查找的键相同;
                    未命中:键为空(该位置没有键————可能接下来的操作就是插入);
                    继续查找:该位置的键和被查找的键不同。

                    用散列函数找到键在数组中的索引,检查其中的键和被查找的键是否相同。如果不同则继续查找(将索引增大,到达数组结尾时折
                    回数组的开头),直到找到该键或者遇到一个空元素。

                    将检查一个数组位置是否含有被查找的键的操作称作探测。

                    开放地址类的散列表的核心思想是与其将内存作用作链表,不如将它们作为在散列表的空元素。这些空元素可以作为查找结束的标
                    志。在具体实现时,我们使用了并行数组,一条保存键,一条保存值。

                    使用空(标记为null)来表示一簇键的结束。如果一个新键的散列值是一个空元素,那么就将它保存在那里;如果不是,我们就顺序
                    查找一个空元素来保存它。

                (2)删除操作
                    在线性探测法中,在删除操作后需要对数组进行修复。即需要将簇中被删除键的右侧的所有键重新插入散列表。

                (3)键簇
                    线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目,也叫做键簇。

                    显然,短小的键簇才能保证较高的效率。随着插入的键越来越多,这个要求很难满足,较长的键簇会越来越多。

                    另外,因为(基于均匀假设)数组的每个位置都有相同的可能性被插入一个新键,长键簇更长的可能性比短键簇更大,因为新键的散列
                    值无论落在簇中的任何位置都会使簇的长度+1。

                (4)性能分析

                    命题————在一张大小为M并含有N=αM个键的基于线性探测的散列表中,基于均匀散列假设,命中和未命中的查找所需的探测次数分
                    别为:
                            ~1/2(1+(1/1-α))和~1/2(1+(1/(1-α)e2))
                    特别是当α约为1/2时,查找命中所需要的探测次数约为3/2,未命中所需要的约为5/2。当α趋近于1时,这些估计值的精确度会下降,
                    但不需要担心这些情况,因为我们会保证散列表的使用率小于1/2(动态数组方式)。

                (5)拉链法与线性探测法两者的比较
                    ①α=N/M值的不同含义(其中M是索引数,N是键的数量)
                        对于拉链法α是指每条链表(即数组中每个索引位置对应的链表)的长度,因此一般大于1;

                        对于线性探测法,α是表中已被占用的空间的比例,所以其不可能大于1.如果α=1(散列表被占满),则此时未命中的查找会导致
                        无限循环。为了保证性能,我们会动态调整数组的大小来保证使用率在1/8到1/2之间。

                    ②动态调整数组大小
                        线性探测法中,调整数组的大小是必须的;而拉链法中调整数组的大小不是必需的,只需要根据查找耗时和(1+N/M)成正比来
                        选取一个适当的M即可。

                    ③内存方面
                        拉链法为每个键值对都分配了一小块内存;
                        线性探测为整张表使用了两个很大的数组。

                (6)均摊分析
                    当我们动态调整数组大小时,需要找出均摊成本的上限,因为我们知道使散列表长度加倍的插入操作需要大量的探测。

                    命题————假设一张散列表能够自己调整数组的大小,初始为空。基于均匀分摊假设,执行任意顺序的t次查找、插入和删除操作所
                            需的时间和t成正比,所使用的内存量总是表中的键的总数的常数因子范围内。

            4.应用
                在计算机发展的早期,符号表帮助程序员从使用机器语言的数字地址进化到在汇编语言中使用符号名称;在现代应用中,符号名称的含义
                能够通行于跨越全球的计算机网络。

                (1)实现的选择
                    相对于二叉查找树,散列表的有点在于代码更简单,且查找时间最优(常数级别,只要键的数据类型是标准的或者简单到我们可以为
                    它写出满足(或者近似满足)均匀性假设的高效散列函数即可)。

                    二叉查找树相对于散列表的优点在于抽象结构更简单(不需要设计散了函数),红黑树可以保证最坏情况下的性能且它能够支持的
                    操作更多(如排名、选择、排序和范围查找)。

                    根据经验,大多数程序员的第一选择都是散列表,在其他因素更重要时才会选择红黑树。

                (2)散列表适当的优化
                    ①当键或值是原始数据类型时,我们可以使用原始数据类型来替代之前的key,以此来节省引用,节省内存(练习3.5.4)。
                    ②重复键————可以考虑在实现中允许数据结构保存重复的键值对,并在查找时返回给定的键所对应的任意值之一;也可以加入一个
                               方法来返回给定的键对应的所有值(练习3.5.9和练习3.5.10)。

                    约定之后使用ST来表示有序符号表,HashST来表示有序性操作无关紧要且拥有散列函数的散列表。

                (3)集合
                    某些符号表的用例不需要处理值,它们只需要能够将键插入表中并检测一个键在表中是否存在。因为我们不允许重复的键。此时,
                    我们将该符号表当作一个集合来使用,其只处理所有键的集合,和相应的值无关。

                    可以联想到,其实当作Java中的Set一样使用。

                    应用————
                        ①dedup————简单来说就是通过调用Set来去掉输入流中的重复项的程序。
                        ②白名单和黑名单

                (4)字典类
                    即将符号表当作字典类来使用,通过连续的put()操作构造一张符号表以备get()查询。许多应用程序都可以将符号表看做是一个
                    可以方便地查询并更新其中信息地动态字典。

                    应用————电话黄页、字典、账户信息、基因组学、实验数据、编译器、文件系统、互联网DNS

                (5)索引类
                    主要特点在于每个键都有一个与之关联地值,因此基于关联型抽象数组来为一个键指定一个值地符号表数据类型正合适。相对于
                    "字典类"中的一对一关系,这里是一个一对多的关系。

                    具体将每个键关联的所有值都放入一个数据结构中(比如Queue),并用它作为值就可以轻松地构造一个索引。

                    此处还引入了一个反向索引的概念,即可以通过值反向找到其所对应的键。

                    应用————商业交易、网络搜索、电影和演员;
                    反向索引应用————互联网电影数据库、图书索引、编译器、文件搜索、基因组学;

                (6)稀疏向量
                    稀疏向量是指矩阵中的大多数项都是0.
                    主要是符号表在科学和数学计算领域所起到的重要作用。具体是在矩阵和向量的乘法中使用。

                    应用————主要就在于使用符号表来替换二维数组表示矩阵,这样可以使矩阵的乘法运算的效率提升。

                    具体就是使用a[i].put(j,val)来表示矩阵中的值并使用a[i].get(j)来获取值,而不是通过之前二维数组中的a[i][j]来操作。
                    这样对于巨型矩阵,可以大大地提高效率。

            5.符号表的综述————

                符号表一章结束了,有了前面的学习,期望散列表能够支持和数组大小无关的常数级别的查找和插入操作是可能的。对于任意的符号表
                实现,这个期望都是理论上的最优性能。但散列表仍然需要注意以下项才可能保证前面说的常数级别————
                (1)每种类型的键都需要一个优秀的散列函数;
                (2)性能保证来自于散列函数的质量;
                (3)散列函数的计算可能复杂而且昂贵;
                (4)难以支持有序性相关的符号表操作。




