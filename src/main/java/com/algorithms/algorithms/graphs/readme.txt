图(graphs)

        相对于之前的查找与排序,图的概念相对比较陌生。简单来说,图就是相连的结点所表示的模型。

        图算法中需要解决的问题————沿着这些连接能否从一个结点到达另一个结点?有多少个结点和指定的结点相连?两个结点之间最短的连接是哪一
        条?

        常见应用————
            地图————处理有关结点(十字路口)之间多条连接(公路)的信息;
            网页信息————在网路上定位信息的搜索引擎的关键组键;
            电路、任务调度、商业交易、配对、计算机网络、软件、社交网路。

        之后会依次接触如下四种最重要的图模型————
            (1)无向图(简单连接)————顺便接触整理最基本的图概念;
            (2)有向图(连接有方向性);
            (3)加权图(连接带有权值);
            (4)加权有向图(连接既有方向性又带有权值)。

        ◉图的定义和绘出的图像是无关的

        一.无向图

            (1)定义与术语表

                ①图————图是由一组顶点和一组能够将两个顶点相连的边组成的。
                顶点、边、图的定义和绘出的图像是无关的。

                ②特殊的图————
                    自环————即一条连接一个顶点和其自身的边。即一个顶点拥有只属于自己的边。
                    平行边————连接同一对顶点的两条边相互称为平行边。即两个顶点之间可能拥有多条边。
                    一般将含有平行边的图称为多重图,而将没有平行边或自环的图称为简单图。

                ③相关概念
                    两个顶点相邻、边依附于两个顶点、顶点的度数(依附于它的边的总数)、子图(一幅图所有边的一个子集(以及它们所依附的所
                    有顶点)组成的图。许多问题都需要识别各种类型的子图,特别是能够顺序连接一系列顶点的边所组成的子图)。

                    路径(由边顺序连接的一些列顶点)、简单路径(一条没有重复顶点的路径)、环(一条至少含有一条边且起点和终点相同的路径)、
                    简单环(一条除了起点和终点必须相同之外不含有重复顶点和边的环)、路径(或环)的长度(其中包含的边数)、顶点的连通

                    连通图————如果从任意一个顶点都存在一条路径到达另一个任意顶点,则称这幅图为连通图。
                    一幅非连通图由若干连通的部分组成,它们都是其极大连通子图。

                    图视角下的树概念————
                    树————树是一幅无环连通图。互不相连的树组成的集合称为森林。
                    生成树————连通图的生成树是它的一幅子图,它含有图中的所有顶点且是一棵树。图的生成树森林是它的所有连通子图的生成树
                              集合。
                    树的定义非常通用,稍做改动就可以变成用来描述程序行为的(函数调用层次)模型和数据结构(二叉查找树、2-3树等)。我们做
                    如下规定,当且仅当一幅含有V个结点的图G满足下列5个条件之一时,它就是一棵树:
                    G有V-1条边且不含有环;G有V-1条边且是连通的;G是无环图,但删除任意一条边都会使它不再连通;G中的任意一对顶点之间仅存
                    在一条简单路径。

                    图的密度————只已经连接的顶点对占有所有可能被连接的顶点对的比例。在稀疏图中,被连接的顶点对很少;而在稠密图中,只有
                                少部分顶点对之间没有边连接。

                    二分图————是一种能够将所有结点分为两部分的图,其中图的每条边所连接的两个顶点都分别属于不同的部分。


            (2)图的数据结构及其相关

                ①数据结构
                    选择数据结构的时候,需要有考虑两点:该种数据结构必须为可能在应用中碰到的各种类型的图预留足够的空间;同时具体API的实
                    现一定要快————因为这些API是开发处理图的各种用例的基础。

                    主要有三种图的表示方法————
                        邻接矩阵————使用一个V乘V的布尔矩阵。当顶点v和顶点w之间有相连接的边时,定义v行w列的元素值为true,否则为false;
                        边的数组————使用一个Edge类,它含有两个int实例变量;
                        邻接表数组(邻接表)————可以使用一个以顶点为索引的列表数组,其中的每个元素都是和该顶点相邻的顶点列表(链表)。该
                                            种表示方式不适用于存在平行边的情况。

                ②使用邻接表的表示方式
                    在该方式中,每条表都会出现两次。

                    此时,性能特点如下————
                        使用的空间和V+E成正比;添加一条边所需的时间为常数;遍历顶点V的所有相邻顶点所需的时间和V的度数成正比(处理每个
                        相邻顶点所需的时间为常数)。

                        此时边的插入顺序决定了Graph的邻接表中顶点的出现顺序。

                        更进一步的,我们可以用Set来替换数组索引对应的链表或bag,这时邻接表升级为邻接集。

            (3)图的处理算法的设计模式

                    图相关算法设计的首要目标是 将图的表示和实现分离开来。所以为每个任务创建一个相应的类,用例创建相应的对象来完成任务。
                    类的构造函数一般会在预处理中构造各种数据结构(图结构)。典型的用例程序会构造一幅图,将图传递给实现了某个算法的类(作
                    为构造函数的参数),然后调用用例的方法来获取图的各种性质。



            (4)深度优先搜索
                    我们常常通过系统地检查每一个顶点和每一条边来获取图的各种性质。但图的许多其他性质和路有关,因此很自然的想法是沿着图
                    的边从一个顶点移动到另一个顶点。

                    Tremaux搜索

                    深度优先搜索(DFS)————
                        要搜索一幅图,只需用一个递归方法来遍历所有顶点。在访问其中一个顶点时:将它标记为已访问;递归地访问它的所有没有
                        被标记过的邻居顶点。
                        这里的深度优先搜索,我认为的就是只要递归的一个顶点其旁系顶点有一个可以访问,则会一直沿着这条路径往深处走,这
                        就是所谓的深度优先搜索。

                    深度优先搜索轨迹跟踪需注意的两点————
                            算法遍历边和访问顶点的顺序与图的表示是有关的;深度优先搜索中每条边都会被访问两次(虽然第二次时总会发现这
                            个顶点已经被标记过)。这意味着深度优先搜索的轨迹可能会比你想象的长一倍!

                    应用————
                            连通性问题————给定一幅图,回答两个给定的顶点是否连通?或者图中有多少个连通子图?等类似问题。
                            单点路径————给定一幅图和一个起点s,回答从s到给定目的顶点v是否存在一条路径?如果有,找出这条路径。
                            连通性分量————深度优先

                    命题————①深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比;
                            ②使用深度优先搜索得到从给定起点到任意标记顶点的路径所需的时间与路径的长度成正比。
                            ③深度优先搜索的预处理使用的时间和空间与V+E成正比且可以在常数时间内处理关于图的连通性查询————
                                理论上深度优先搜索比union-find算法快,因为它能保证所需的时间是常数而union-find算法不行;但在实际应
                                用中,这点差异微不足道。union-find算法其实更快,因为它不需要完整地构造并表示一幅图。更重要的是,union-find
                                算法是一种动态算法,但深度优先搜索则必须要对图进行预处理。
                            ④检测环
                            ⑤双色问题


            (5)广度优先搜索
                    广度优先搜索主要在于单点最短路径这个问题的解决。
                    相对于深度优先那种要把一条路径上可以访问的顶点全部访问完(即可以往深度方向走就往深度方向走),广度优先是优先于先访
                    问同一个距离单位上的所有顶点,然后再访问下一个距离单位上的所有顶点,以此类推。

                    广度优先搜索(BFS)————
                        广度优先搜索算法使用了一个队列来保存所有已经被标记过但其邻接表还未被检查过的顶点。先将起点加入队列,然后重复
                        以下步骤知道队列为空:取队列中的下一个顶点v并标记它;将与v相邻的所有未被标记过的顶点加入队列。
                        在搜索中我们都会先将起点存入数据结构中,然后重复以下步骤直到数据结构被清空:取其中的下一个顶点并标记它;将v的
                        所有相邻而又未被标记的顶点加入数据结构。

                        注意广度优先搜索算法不是递归的,所以其不像递归中隐式使用的栈,它显式地使用了一个队列。

                        具体来说就是将顶点按照它们和s的距离的顺序加入或者离开队列的。

                        广度优先算法就像是这样"大家先走一步,然后再走一步,直到无路可走"。

                    命题————①对于从s可达的任意顶点v,广度优先搜索都能找到一条从s到v的最短路径(没有其他从s到v的路径所含的边比这条路径
                            更少)。
                            ②广度优先搜索所需要的时间在最坏情况下和V+E成正比。

            (6)深度优先搜索与广度优先搜索区别
                    ①深度优先搜索就好像是一个人在走迷宫;广度优先搜索则好像是一组人在一起朝各个方向走迷宫,遇到分叉则分裂人往分叉的
                     各个路径都走一个人。

                    ②两个算法的不同之处在于从数据结构中获取下一个顶点的规则————对于广度优先搜索来说是获取最早加入的顶点;对于深度优先
                     搜索来说是最晚加入的顶点。这种差异得到了处理图的两种完全不同的视角,尽管无论使用哪种规则,所有与起点连通的顶点和边
                     都会被检查到。

                    ③深度优先搜索不断深入图中并在栈中保存了所有分叉的顶点;广度优先搜索则像扇面一般扫描图,用一个队列保存访问过的最前
                     端的顶点。

                    ④深度优先搜索探索一幅图的方式是寻找离起点更远的顶点,只在碰到死胡同时才访问近处的顶点;广度优先搜索则会首先覆盖起点
                     附近的顶点,只在临近的所有顶点都被访问了之后才向前进。

                    ⑤深度优先搜索的路径通常较长而且曲折,广度优先搜索的路径则短而直接。

            (7)符号图

                    所谓的符号图,我认为实际上就是将顶点的String和index整数索引做了一个映射,然后再用index整数索引去做常规图的邻接表
                    数组的索引。

                    同时,String都能做映射,那自然其他引用类型对象都可以做映射了,所以符号图实际上通过这种映射关系多引入了一个数据维度。

                    其次其和二分图也有关系。

                    这里以String类型为例————
                    符号图需要三种数据结构:一个符号表st,键的类型为String(顶点名),值的类型为int(索引);
                                         一个数组keys[],用作反向索引,保存每个顶点索引所对应的顶点名;
                                         一个Graph对象G,它使用索引来引用图中顶点。

        二.有向图

            有向图中,边是单向的:每条边所连接的两个顶点都是一个有序对,它们的邻接性是单向的。

            (1)定义与术语表

                ①定义
                    一幅有方向的图(或有向图)是由一组顶点和一组有方向的边组成的,每条有方向的边都连接着有序的一对顶点。

                ②术语表
                    出度(由该顶点指出的边的总数)、入度(指向该顶点的边的总数)、头(一条有向边的第一个顶点)、尾(一条有向边的第二个顶点)、

                    有向路径(一系列顶点组成,对于其中的每个顶点都存在一条有向边,从它指向序列的下一个顶点)
                    有向环(一条至少含有一条边且起点和终点相同的有向路径)
                    简单有向环(一条除了起点和终点必须相同之外,不再含有重复的顶点和边的环)
                    路径或环的长度即为其中所包含的边数。

                    注意有向图中的可达性和无向图中的连通性。

                ③有向图的可达性

                    问题
                        单点可达性————给定一幅有向图和一个起点s,回答"是否存在一条从s到达给定顶点v的有向图路径?"
                        多点可达性————给定一幅有向图和顶点的集合,回答"是否存在一条从集合中的任意顶点到达给定顶点v的有向图路径?"

                    命题————在有向图中,深度优先搜索 标记 由一个集合的顶点可达的所有顶点 所需的时间与被标记的所有顶点的出度之和成正比。

                    算法选择
                        深度优先搜索是一种适用于处理有向图的算法,每条边都只会被表示一次。

                    应用————
                        标记-清除的垃圾收集————在程序执行的任何时候都有某些对象是可以被直接访问的,而不能通过这些对象访问到的所有对象
                        都应该被回收释放内存。

                ④有向图的寻路

                    问题
                        单点有向路径————给定一幅有向图和一个起点s,回答"从s到给定目的顶点v是否存在一条有向路径?"
                        单点最短有向路径————给定一幅有向图和一个起点s,回答"从s到给定目的顶点v是否存在一条有向路径?"存在则找出其中最
                                          短的那条(所含边数最少)。

            (2)环和有向无环图
                该节主要是两大点,一是在有向图中判断环;二是如果判断无环,则在此有向无环图中做拓扑排序(将图中结点进行排序的一种方式)。

                ①有向环
                    没有计算机的帮助,在一幅普通的有向图中找出有向环可能会很困难。

                    具体有向图中环的判定见相关代码。

                ②调度问题
                    即给定一组任务并在一定限制条件下安排它们的执行顺序。这些限制条件如任务的执行方法和起始时间;任务的耗时以及消耗的
                    其他资源;优先级限制。
                    不同类型的限制条件会产生不同类型不同难度的调度问题。

                    在有向图中,优先级限制下的调度问题等价于拓扑排序问题。

                ③拓扑排序问题(拓扑排序问题首先是一个可达性的问题)
                    给定一幅有向图,将所有的顶点排序,使得所有的有向边均从排在前面的元素指向排在后面的元素(或者说明无法做到这一点)。

                    一般来说,如果一个有优先级限制的问题中存在有向环,那么这个问题肯定是无解的。

                    命题————由上可知,当且仅当一幅有向图是无环图时,它才能进行拓扑排序。

                    顶点的深度优先次序与拓扑排序——————
                        使用深度优先搜索遍历图时,遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。一般人们感
                        兴趣的是顶点的以下三种排列顺序:
                        前序————在递归调用之前将顶点加入队列——————这就是深度优先搜索结点的访问顺序,最先访问的顶点先入队列,后访问的后入
                                                               队列;
                        后序————在递归调用之后将顶点加入队列——————后序不完全是"前序"的反方向,应该说是在一个深度路径上和"前序"相反,但
                                                               是在深度路径的访问顺序上和"前序"相同。
                        逆后序————在递归调用之后将顶点压入栈——————顶点遍历完成顺序的逆。应该说其访问顶点的顺序是和"后序"一样的,其特
                                                                殊点在于其是放在栈中的。

                    命题————  Ⅰ.一幅有向无环图的拓扑顺序即为所有顶点的逆后序排列。
                              Ⅱ.使用深度优先搜索对有向无环图进行拓扑排序所需的时间和V+E成正比。

                    在实际应用中,拓扑排序和有向环的检测总会一起出现,因为有向环的检测是排序的前提。所以解决任务调度类应用通常需要以下
                    三步:指明任务和优先级条件;不断检测并去除有向图中的所有环,以确保存在可行的方案;使用拓扑排序解决调度问题。

                    类似地,调度方案地任何变动之后都需要再次检查是否存在环,然后再计算新的调度安排。

            (3)有向图中的强连通性

                ①定义
                    如果两个顶点v和w是互相可达的,则称它们为强连通的。如果一幅有向图中的任意两个顶点都是强连通的,则称这幅有向图也是强
                    连通的。

                    两个顶点是强连通的当且仅当它们都在一个普通的有向环中。

                ②强连通分量
                    和无向图中的连通性一样,有向图中的强连通性也是一种顶点之间的等价关系。其包含了自反性、对称性和传递性。

                    作为一种等价关系,强连通性将所有顶点分为了一些等价类,每个等价类都是由互相均为强连通的顶点的最大子集组成的。这些子
                    集被称为强连通分量。

                    需要注意的是,强连通分量的定义是基于顶点的,而非边。

                    一个含有V个顶点的有向图含有1~V个强连通分量————一个强连通图只含有一个强连通分量,而一个有向无环图中则含有V个强连
                    通分量。

                    在一幅图中寻找强连通分量的算法,kosaraju算法。

                    命题————
                        Ⅰ.使用深度优先搜索查找给定有向图G的反向图F,根据由此得到的所有顶点的逆后序再次用深度优先搜索处理有向图G(
                           Kosaraju算法),其构造函数中的每一次递归调用所标记的顶点都在同一个强连通分量中。
                        Ⅱ.Kosaraju(处理有向图的反向图并进行两次深度优先搜索)算法的预处理所需的时间和空间与V+E成正比且支持常数时
                           间的有向图强连通性的查询。

                    问题————
                        给定一幅图,回答"给定的两个顶点是强连通的吗?" 这副有向图中含有多少个强连通分量?

                ③有向图中可达性的性能
                    在无向图中,寻找连通性时,其需要线性级别的预处理时间就能支持常数级别查询操作。在有向图中寻找可达性时,能达到这种常
                    数级别吗?
                    在有向图的可达性问题中,用远小于平方级别的空间支持常数级别的查询的一般解决方案仍然是一个有待解决的研究问题。

                    传递闭包————有向图G的传递闭包是由相同的一组顶点组成的另一幅有向图,在传递闭包中存在一条从v指向w的边当且仅当在G中
                               w是从v可达的。

        三.最小生成树(加权无向图)

            0.引子
                加权图————一种为每条边关联一个权值或是成本的图模型。

                生成树————是一幅图的一棵含有其所有顶点的无环连通子图。

                最小生成树————一幅加权图中,最小生成树(MST)指其所有生成树中权值和最小的一棵。

                约定与性质————①只考虑连通图;
                             ②边的权重不一定表示距离;
                             ③边的权重可能是0或者复数;
                             ④所有边的权重都各不相同。


            1.原理
                (1)切分定理
                    ①切分————图的一种切分是将图的所有顶点分为两个非空且不重叠的集合。横切边是一条连接两个属于不同集合的顶点的边。

                    通常,我们通过指定一个顶点集并隐式地认为它地补集为另一个顶点集来指定一个切分。这样,一条横切边就是连接该集合的一个
                    顶点和不在该集合中的另一个顶点的一条边。

                    注意,横切边可能不止一条。

                    ②切分定理————在一幅加权图中,给定任意的切分,它的横切边中的权重最小者必然属于图的最小生成树

                    注意,一次切分中权重最小的横切边并不一定是该次切分所有横切边中唯一属于图的最小生成树的边。

                    ③贪心算法
                    切分定理是解决最小生成树问题的所有算法的基础。更确切的说,这些算法都是一种贪心算法的特殊情况:使用切分定理找到最小
                    生成树的一条边,不断重复直到找到最小生成树的所有边。

                    同属于贪心算法之下的不同算法相互之间的不同之处在于 保存切分 和 判定权重最小的横切边 的方式。

                    命题————(最小生成树的贪心算法)  将含有V个顶点的任意加权连通图中属于最小生成树的标记为黑色的方式:初始状态下所有
                                                 边均为灰色,找到一种切分,它产生的横切边均不为黑色。将它权重最小的横切边标记为黑
                                                 色。反复,直到标记V-1条黑色边为止。

                    数据结构————这里引入了边的对象,具体见代码。


                (2)Prim算法
                    是一种计算最小生成树的算法,也是属于贪心算法的一种。具体分为即时实现和延时实现。

                    基本思想是————每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点,每次总是将下一条连接树中的顶点与不
                                 在树中的顶点且权重最小的边(黑色表示)加入树中(即由树中的顶点所定义的切分中的一条横切边)。

                    数据结构————我们会用以下方法表示树中的顶点、边和横切边:
                               ①顶点————使用一个由顶点索引的布尔数组marked[],在树中则marked[v]=true.
                               ②边————两种数据结构选一:一条队列mst来保存最小生成树中的边;由顶点索引的Edge对象的数组edgeTo[].
                                                    edgeTo[v]为将v连接到树中的Edge对象
                               ③横切边————使用一条优先队列MinPQ<Edge>来根据权重比较所有边。

                    维护横切边的集合————每当我们向(最小生成)树中添加了一条边后,也向树中添加了一个顶点。要维护一个包含所有横切边的集
                                      合,就要将连接这个顶点和其他所有不在树中的顶点的边加入优先队列中(可以用marked[]来识别这样的
                                      边)。

                    Prim算法的延时实现与即时实现——————
                               这里对于"延时"与"即时"的个人理解。我觉得主要是对于代码中的那个最小优先队列而言。因为Prim算法的思想
                               就是从离生成树最近的顶点中找到权重最小的,所以不管是"即时"还是"延时",代码中总会有优先队列的存在。

                               即时实现情况下,每次往优先队列中放入的元素就是即时计算出的该顶点对应的所有横切边中最小的边;

                               延时实现情况下,是先将该顶点的所有横切边都加入优先队列中,然后需要的时候,取出时再从中取出最小的。

                               所以即时实现时,就直接用优先队列来装最终的最小生成树的边;而延时实现时,还会额外使用一个队列来装最小
                               生成树的边。


                    命题————①Prim算法能够得到任意加权连通图的最小生成树。
                            ②Prim算法的延时实现计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间与E成正比,所需的时间
                             与ElogE成正比(最坏情况)。
                            ③Prim算法的即时实现计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间与V成正比,所需的时间
                             与ElogV成正比(最坏情况)。

                (3)Kruskal算法

                    主要思想————按照边的权重顺序(从小到大)处理它们,将边加入最小生成树,加入的边不会与已经加入的边构成环,直到树中含有
                               V-1条边为止。这些被选出来的边逐渐由一片森林合并为一棵树,这颗最终的树就是最小生成树。

                    数据结构————具体会用以下三种数据类型来实现算法:
                               ①优先队列————来将所有的边按照权重排序;
                               ②union-find————来识别会形成环的边;
                               ③队列————保存最小生成树的所有边。

                    命题————①Kruskal算法能够计算任意加权连通图的最小生成树。
                            ②Kruskal算法计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和E成正比,所需的时间和ElogE
                             成正比(最坏情况)。

                    效率————Kruskal算法一般还是比Prim算法要慢,因为在处理每条边时除了两种算法都要完成的优先队列操作之外,它还需要进行
                            一次connect()操作。


        四.最短路径(加权有向图)

            0.引子
                在加权有向图中,每条有向路径都有一个与之关联的路径权重,它是路径中的所有边的权重之和。

                在一幅加权有向图中,从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。

                问题————给定一幅加权有向图和一个起点s,回答"从s到给定的目的顶点v是否存在一条有向路径?"如果有,找出最短(总权重最小)的
                        那条路径。

                约定与性质————①路径是有向的;
                             ②权重不一定等价于距离;
                             ③并不是所有顶点都是可达的;
                             ④负权重会使问题更复杂;
                             ⑤最短路径一般都是简单的;
                             ⑥最短路径不一定是唯一的;
                             ⑦可能存在平行边和自环;

                最短路径树————给定一幅加权有向图和一个顶点s,以s为起点的一棵最短路径树是图的一幅子图,它包含s和从s可达的所有顶点。这颗
                             有向树的根结点为s,树的每条路径都是有向图中的一条最短路径。
                             通过构造这颗最短路径树,可以为用例提供从s到图中任何顶点的最短路径。

            1.最短路径

                (1)松弛
                    最短路径API的实现都基于一个被称为松弛(relaxation)的简单操作。
                    具体松弛可以分为两类:边的松弛与顶点的松弛。前者是后者的基础。

                    松弛这个术语来自于用一根橡皮筋沿着连接两个顶点的路径紧紧展开的比喻:放松一条边就类似于将橡皮筋转移到一条更短的路
                    径上,从而缓解了橡皮筋的压力。

                    ①边的松弛————放松边v->w意味着检查从s到w的最短路径是否是先从s到v,然后再由v到w。如果是,则根据这个情况更新数据结构
                                的内容。
                                边的放松操作之后可能出现两种情况:
                            ===>边失效(v到达w的最短路径distTo[v]与e.weight()之和这个值不小于distTo[w]),即指不能用这个Edge实例
                                对象来当作目标顶点w的最短路径的最后一条边。

                            ===>边有效并更新(如果v到达w的最短路径distTo[v]与e.weight()之和这个值大于等于distTo[w],则需要进一步
                                更新当前目标顶点w的最短路径,同时其势必是通过传入的Edge实例的)。

                                当边有效并更新的时候,我们说传入的Edge的放松是成功的。

                    ②顶点的松弛————顶点的松弛是边的松弛的延申。如果从一个给定顶点指出的所有边都被放松了,则称该顶点被松弛了。


                (2)最短路径算法的理论基础
                    边的松弛操作是一项非常容易实现的重要操作,它是实现最短路径算法的基础。

                    ①最优性条件
                        该条件证明了判断路径是否是否为最短路径的全局条件与在放松一条边时所检测的局部条件是等价的。

                        命题————(最短路径的最优条件) 令G为一幅加权有向图,顶点s是G中的起点,distTo[]是一个由顶点索引的数组,保存的是
                                G中路径的长度。对于从s可达的所有顶点v,dist[v]的值是从s到v的某条路径的长度,对于从s不可达的所有顶点
                                v,该值为无穷大。当且仅当对于从v到w的任意一条边e,这些值都满足distTo[w]<=distTo[v]+e.weight()时(
                                换句话说,不存在有效边)时,它们是最短路径的长度。

                        命题————(通用最短路径算法)  将distTo[s]初始化为0,其他distTo[]元素初始化为无穷大,继续如下操作:放松G中的任
                                意边,直到不存在有效边为止。对于任意从s可达的顶点w,在进行这些操作之后,distTo[w]的值即为从s到w的最
                                短路径的长度(且edgeTo[w]的值即为该路径上的最后一条边)。


                (3)无环加权有向图中的最短路径算法
                        主要是在无环的前提条件下学习一种比Dijkstra算法更快、更简单的在无环加权有向图中找出最短路径的算法。该算法的
                        特点在于————
                            能够在线性时间内解决单点最短路径问题;
                            能够处理负权重的边;
                            能够解决相关的问题,例如找出最长的路径。

                        算法的步骤————将distTo[s]初始化为0,其他distTo[]元素初始化为无穷大,然后一个一个地按照拓扑顺序放松所有顶点。

                        命题————按照拓扑顺序放松顶点,就能在和E+V成正比地时间内解决无环加权有向图的单点最短路径问题。

                                该种算法不需要统计每个顶点是否被在最短路径中的那个布尔数组marked[]:因为是按照拓扑顺序处理无环有向
                                图中的顶点,所以不可能再次遇到已经被放松过的顶点。

                                该算法是已知加权图是无环的情况下,找出最短路径的最好方法。

                                基于拓扑排序的方法比Dijkstra算法快的倍数与Dijkstra算法中所有优先队列操作的总成本成正比。

                        应用————①最长路径
                                 在无环加权有向图中寻找最长路径的问题,边的权重可正可负。

                                 问题————无环加权有向图中的单点最长路径:给定一幅无环加权有向图(边的权重可能为负)和一个起点s,回答"
                                         是否存在一条从s到给定的顶点v的路径?"如果有,找出最长(总权重最大)的那条路径。

                                 从最短路径算法变出的两个思路————
                                                ===>将副本中的所有边的权重取相反数。这样副本中的最短路径即为原图中的最长路径;
                                                ===>修改最短路径算法,distTo[]初始值变为Double.NEGATIVE_INFINITY并改变relax()
                                                    松弛方法中的不等式的方向。

                                 命题————解决无环加权有向图中的最长路径问题所需的时间与E+V成正比。

                                 ②并行任务调度
                                   优先级限制下的并行任务调度————
                                        关键路径————由优先级限制指定的每一列任务都代表了调度方案的一种可能的时间下限。如果将一系列
                                                   任务的长度定义为完成所有任务的最早可能时间,那么最长的任务序列就是问题的关键路
                                                   径,因为在这份序列中任何任务的启动延迟都会影响到整个项目的完成时间。

                                        命题————解决优先级限制下的并行任务调度问题的关键路径法所需的时间为线性级别。

                                   相对最后期限限制下的并行任务调度————
                                        如需要某个任务必须在指定的时间点之前开始,即指定和另一个任务的开始时间的相对时间。

                                        命题————相对最后期限限制下的并行任务调度问题是一个加权有向图中的最短路径问题(可能存在环和
                                                负权重边)。


                (4)一般加权有向图中的最短路径问题(相对(4)引入了负权重与环)
                        考虑既可能含有环也可能含有负权重的边的加权有向图中的最短路径。

                        引入负权重的边对有向图中的最短路径的影响————最明显的改变就是当存在负权重的边时,权重较小的路径含有的边可能会
                                                                比权重较大的路径更多。在只存在正权重的边时,我们的重点在于寻找近
                                                                路;但当存在负权重的边时,我们可能会为了经过负权重的边而绕弯(因为
                                                                负权重肯定较小)。这种效应使得我们要将查找"最短"路径的感觉转变为
                                                                对算法本质的理解。

                        负权重环————
                                加权有向图中的负权重环是一个总权重(环上的所有边的权重之和)为负的有向环。

                                一定不能出现负权重环,因为进入后就出不来了,我们只要围着这个环兜圈子就能得到权重任意短的路径。

                                命题————当且仅当加权有向图中至少存在一条从s到v的有向路径且所有从s到v的有向路径上的任意顶点都不存在
                                        于任何负权重环中时,s到v的最短路径才是存在的。

                                类比于加权无向图中拓扑排序之前需要进行环的检测一样,这里一般加权有向图中进行最短路径的检测与查找时,
                                我们也需要进行负权重环的检测。

                                负权重环的检测————
                                        检测负权重环来避免陷入无限的循环中。

                        具体在检测一般加权有向图中无负权重环后,我们就可以进一步使用Bellman-Ford算法来寻找其中的最短路径了。

                (5)Dijkstra算法与Bellman-Ford算法
                    ①Dijkstra算法
                        类似于之前加权无向图中的Prim算法:构造最小生成树的每一步都向这棵树中添加一条新的边。Dijkstra算法采用了类似的
                        方法来计算最短路径树。

                        两种算法都会用添加边的方式构造一棵树:Prim算法每次添加的都是离树最近的非树顶点,Dijkstra算法每次添加的都是离
                        起点最近的非树顶点。

                        具体算法步骤————首先将distTo[s]初始化为0,distTo[]中的其他元素初始化为正无穷。然后将distTo[]最小的非树顶
                                       点放松并加入树中,如此这般,直到所有的顶点都在树中或者所有的非树顶点的distTo[]值均为无穷大(
                                       有非连通子图的情况)。

                                       步骤中的"最小非树顶点放松并加入树中",要判断最小我们会如Prim算法中一样,用到最小优先队列。然
                                       后每次从队列中取优先级最小的顶点及其对应的distTo[]值。该值不会小于已被放松过的任意顶点的最
                                       短路径的权重,也不会大于还未被放松过的任意顶点的最短路径的权重。所以这个顶点就是下一个要被放
                                       松的顶点。所有从s可达的顶点都会按照最短路径的权重顺序被放松。

                        命题————
                             ===>Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。
                             ===>在一幅含有V个顶点和E条边的加权有向图中,使用Dijkstra算法计算根结点为给定起点的最短路径树所需的空间
                                 与V成正比,时间与ElogV成正比(最坏情况下)。

                        算法能解决的问题————
                             ===>给定两点的最短路径————给定一幅图加权有向图以及一个起点s和终点t,找到从s到t的最短路径;

                             ===>任意顶点对之间的最短路径————给定一幅加权有向图,回答"给定一个起点s和一个终点t,是否存在一条从s到t的
                                                           路径?如果有,找出最短(总权重最小)的那条路径"

                             ===>欧几里得图中的最短路径————解决单点、给定两点和任意顶点对之间的最短路径问题。

                    ②Bellman-Ford算法

                        命题————(Bellman-Ford算法) 在任意含有V个顶点的加权有向图中给定起点s,且从s无法到达任何负权重环,以下算法能
                                                  够解决其中的单点最短路径问题:将distTo[s]初始化为0,其他distTo[]元素初始化为无
                                                  穷大。以任意顺序放松有向图的所有边,重复V轮。

                        命题————Bellman-Ford算法所需的时间和EV成正比,空间和V成正比。

                        Bellman-Ford算法是很管用的,因为其没有指定边的放松顺序。

                        基于队列的Bellman-Ford算法——————
                            其实,根据经验我们很容易知道在任意一轮中许多边的放松都不会成功:只有上一轮中的distTo[]值发生变
                            化的顶点指出的边才能够改变其他distTo[]元素的值。

                            数据结构———— 一条用来保存即将被放松的顶点的队列queue;
                                        一个由顶点索引的boolean数组onQ[],用来指示顶点是否已经存在于队列中,以防止将顶点重复插入队
                                        列。

                                        这些数据结构能够保证:
                                            队列中不出现重复的顶点;
                                            在某一轮中,改变了edgeTo[]和distTo[]的值的所有顶点都会在下一轮中处理。

                            完整实现该算法,就需要保证在V轮后算法能够终止。实现它的一种方法是显式记录放松的轮数;另一种方法是判断是否
                            有负权重环出现(将图的所有边放松V轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环)。

                        命题————对于任意含有V个顶点的加权有向图和给定的起点s,在最坏情况下基于队列的Bellman-Ford算法解决最短路径问
                                题(或者找到从s可达的负权重环)所需的时间与EV成正比,空间和V成正比。

                (6)套汇问题————
                        将不同货币之间的兑换图抽象为衣服完全的加权有向图,如果有套汇的路径存在,则该路径是负权重环。




